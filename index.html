<!DOCTYPE html>
<html>
<head>
    <!-- Previous head content remains the same -->
    <style>
        /* Previous styles remain the same */
        
        /* Add new styles for task history */
        .task-history {
            margin-top: 40px;
            padding: 20px;
            background: white;
            border-radius: 8px;
        }

        .task-history h2 {
            margin-bottom: 20px;
            font-size: 18px;
            color: #333;
        }

        .history-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .history-stat-box {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }

        .history-stat-box h3 {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }

        .history-stat-box p {
            font-size: 20px;
            font-weight: bold;
            color: #2f3437;
        }

        .history-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .history-table th,
        .history-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        .history-table th {
            background: #f5f5f5;
            font-weight: 600;
        }

        .scroll-container {
            max-height: calc(100vh - 600px);
            overflow-y: auto;
            margin-top: 20px;
        }

        /* Status badges */
        .status-badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-completed {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .status-in-progress {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status-waiting {
            background: #fff3e0;
            color: #ef6c00;
        }
    </style>
</head>
<body>
    <!-- Previous kanban board content remains the same -->

    <div class="task-history">
        <h2>Task History</h2>
        <div class="history-stats">
            <div class="history-stat-box">
                <h3>Total Tasks Created</h3>
                <p id="totalTasksCreated">0</p>
            </div>
            <div class="history-stat-box">
                <h3>Tasks Completed</h3>
                <p id="totalTasksCompleted">0</p>
            </div>
            <div class="history-stat-box">
                <h3>Completion Rate</h3>
                <p id="taskCompletionRate">0%</p>
            </div>
        </div>
        <div class="scroll-container">
            <table class="history-table">
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Task</th>
                        <th>Status</th>
                        <th>Time in Stage</th>
                        <th>Total Time</th>
                    </tr>
                </thead>
                <tbody id="taskHistoryBody">
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Add to your existing variables
        let taskHistory = JSON.parse(localStorage.getItem('gtdTaskHistory')) || [];

        function updateTaskHistory(task, fromColumn, toColumn) {
            const now = new Date();
            const historyEntry = {
                taskId: task.id,
                taskTitle: task.title,
                fromStatus: fromColumn,
                toStatus: toColumn,
                timestamp: now.toISOString(),
                timeInStage: task.lastStatusChange ? 
                    Math.floor((now - new Date(task.lastStatusChange)) / 1000) : 0
            };
            
            taskHistory.unshift(historyEntry);
            localStorage.setItem('gtdTaskHistory', JSON.stringify(taskHistory));
            
            // Update task's status change timestamp
            task.lastStatusChange = now.toISOString();
            
            renderTaskHistory();
        }

        function renderTaskHistory() {
            const tbody = document.getElementById('taskHistoryBody');
            tbody.innerHTML = '';
            
            let totalTasks = new Set(taskHistory.map(h => h.taskId)).size;
            let completedTasks = new Set(taskHistory
                .filter(h => h.toStatus === 'completed')
                .map(h => h.taskId)).size;
            
            document.getElementById('totalTasksCreated').textContent = totalTasks;
            document.getElementById('totalTasksCompleted').textContent = completedTasks;
            document.getElementById('taskCompletionRate').textContent = 
                totalTasks ? Math.round((completedTasks / totalTasks) * 100) + '%' : '0%';

            taskHistory.slice(0, 50).forEach(entry => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${new Date(entry.timestamp).toLocaleString()}</td>
                    <td>${entry.taskTitle}</td>
                    <td>
                        <span class="status-badge status-${entry.toStatus === 'completed' ? 'completed' : 
                            entry.toStatus === 'waiting' ? 'waiting' : 'in-progress'}">
                            ${entry.toStatus}
                        </span>
                    </td>
                    <td>${formatDuration(entry.timeInStage)}</td>
                    <td>${calculateTotalTime(entry.taskId, entry.timestamp)}</td>
                `;
                tbody.appendChild(row);
            });
        }

        function formatDuration(seconds) {
            if (!seconds) return 'N/A';
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            return hours > 0 ? 
                `${hours}h ${minutes}m` : 
                `${minutes}m`;
        }

        function calculateTotalTime(taskId, upTo) {
            const taskEntries = taskHistory
                .filter(h => h.taskId === taskId && new Date(h.timestamp) <= new Date(upTo));
            if (taskEntries.length <= 1) return 'N/A';
            
            const firstEntry = taskEntries[taskEntries.length - 1];
            const totalSeconds = Math.floor(
                (new Date(upTo) - new Date(firstEntry.timestamp)) / 1000
            );
            return formatDuration(totalSeconds);
        }

        // Modify your existing drop function
        function drop(ev) {
            ev.preventDefault();
            const taskId = ev.dataTransfer.getData("text");
            const taskElement = document.getElementById(taskId);
            const targetColumn = ev.target.closest('.column').id;
            
            let task;
            let fromColumn;
            Object.keys(tasks).forEach(column => {
                const taskIndex = tasks[column].findIndex(t => t.id === taskId);
                if (taskIndex !== -1) {
                    task = tasks[column].splice(taskIndex, 1)[0];
                    fromColumn = column;
                }
            });

            if (task) {
                tasks[targetColumn].unshift(task);
                updateTaskHistory(task, fromColumn, targetColumn);
                localStorage.setItem('gtdTasks', JSON.stringify(tasks));
                renderTasks();
            }
        }

        // Modify your saveTask function to include history
        function saveTask() {
            const taskData = {
                title: document.getElementById('taskTitle').value,
                description: document.getElementById('taskDescription').value,
                priority: document.getElementById('taskPriority').value,
                dueDate: document.getElementById('taskDueDate').value,
                lastStatusChange: new Date().toISOString()
            };

            if (currentEditingTask) {
                // Update existing task
                Object.keys(tasks).forEach(column => {
                    const taskIndex = tasks[column].findIndex(task => task.id === currentEditingTask.id);
                    if (taskIndex !== -1) {
                        tasks[column][taskIndex] = {
                            ...currentEditingTask,
                            ...taskData
                        };
                    }
                });
            } else {
                // Create new task
                const newTask = {
                    id: 'task-' + Date.now(),
                    createdAt: new Date().toISOString(),
                    ...taskData
                };
                tasks.inbox.unshift(newTask);
                updateTaskHistory(newTask, null, 'inbox');
            }

            localStorage.setItem('gtdTasks', JSON.stringify(tasks));
            renderTasks();
            closeModal();
        }

        // Initial render should include task history
        renderTasks();
        renderTaskHistory();
    </script>
</body>
</html>
